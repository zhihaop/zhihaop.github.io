---
layout: post
title:  "Leetcode 第 294 场周赛 题解"
date:   2022-05-22 23:31:32 +0800
categories: jekyll update
---


## Leetcode 第 294 场周赛 题解

以后周赛的水题就直接略过了，直入主题。

### [4. 巫师的总力量和](https://leetcode.cn/problems/sum-of-total-strength-of-wizards/)

这题很快就有想法了，大概 10 分钟左右吧。然后推 `单调栈` 和 `debug` 用了不少时间，导致场上没过这题。说明我目前的薄弱点仍然是 `单调栈`，`模拟` 和 `细节`。

**题意**: 给你一个数组 $s[N]$，计算 $\sum_{1 \le i \le j \le N} min(s[i:j]) \times sum(s[i:j])$。其中 $min(s[i:j]) \times sum(s[i:j])$ 称为 $s[i:j]$ 的力量和。

**思路**: 仍然以 `后缀` 的方向考虑。假设以 $s[i-1]$ 结尾数组的 `总力量和` 为 $dp(i - 1)$，考虑以 $s[i]$ 结尾的情况。

1. 如果 $s[i]$ 是 $s[1:i]$ 的最小值，那么

    $dp(i) = s[i] \times \sum_{1 \le j \le i} sum(s[j:i])$。

    $=s[i] \times \sum_{1 \le j \le i} (s_1[i] - s_1[j-1])$

    $=s[i] \times ((i + 1) s_1[i] - \sum_{1 \le j \le i}s_1[j-1])$

    $=s[i] \times ((i + 1) s_1[i] - s_2[i - 1])$

    其中 $s_1[N]$ 为 $s[N]$ 的前缀和， $s_2[N]$ 为 $s1[N]$ 的前缀和。

2. 否则，必然存在一个最大的 $k$，满足 $k \lt i$ 且 $s[k] \lt s[i]$。

    - 在 $s[k+1:i]$ 中，$s[i]$ 仍然是最小值，对答案贡献为

        $s[i] \times \sum_{k+1 \le j \le i} sum(s[j:i])$

        $=s[i] \times \sum_{k+1 \le j \le i} (s_1[i] - s_1[j-1])$

        $=s[i] \times ((i - k)s_1[i] - (s_2[i - 1] - s_2[k - 1]))$

    - 在 $s[1:k]$ 中，$s[i]$ 不是最小值了，该区间对答案贡献为

        $\sum_{1\le j \le k} min(s[j:i]) \times sum(s[j:i])$

        $=\sum_{1\le j \le k} min(s[j:k]) \times sum(s[j:k] + sum(s[k+1:i]))$

        $=\sum_{1\le j \le k} min(s[j:k]) \times sum(s[j:k]) + sum(s[k+1:i]) \times \sum_{1\le j \le k} min(s[j:k])$

        $=dp(k) + (s_1[i] - s_1[k]) \times \sum_{1\le j \le k} min(s[j:k])$

        $=dp(k) + (s_1[i] - s_1[k]) \times dp_2(k)$

不妨设 $dp_2(i) = \sum_{1\le j \le i} min(s[j:i])$。

1. 如果 $s[i]$ 是 $s[1:i]$ 的最小值，那么 $dp_2(i)=i \times s[i]$
2. 否则，必然存在一个最大的 $k$，满足 $k \lt i$ 且 $s[k] \lt s[i]$
   - 那么在 $s[k+1:i]$ 中，$s[i]$ 仍然是最小值，对 $dp_2(i)$ 贡献为 $(i - k) \times s[i]$
   - 在 $s[1:k]$ 中，$s[i]$ 不是最小值了，该区间对 $dp_2$ 贡献为 $dp_2(k)$

现在 $dp(i)$ 的计算问题都解决了。问题只剩下如何寻找满足 $s[k] \lt s[i]$ 且 $k \lt i$ 的最大的 $k$。很明显这是一个 `NGE` (Next Greater Element) 问题，可以使用 `单调栈` 寻找最近的满足 $s[k] \lt s[i]$ 的元素。

因此该题是 `单调栈优化动态规划` 问题，时间复杂度 $O(N)$，空间复杂度 $O(N)$。

```c++
using ll = long long;
const int MOD = 1e9 + 7;

class Solution {

public:
    int totalStrength(vector<int> &strength) {
        int n = strength.size();
        auto sum1 = vector<ll>(n + 1);
        auto sum2 = vector<ll>(n + 1);

        auto dp1 = vector<ll>(n + 1);
        auto dp2 = vector<ll>(n + 1);


        ll ans = 0;
        deque<int> q;
        for (int i = 1; i <= n; ++i) {
            sum1[i] = (sum1[i - 1] + strength[i - 1]) % MOD;
            sum2[i] = (sum2[i - 1] + sum1[i]) % MOD;

            while (!q.empty() && strength[q.back()] > strength[i - 1]) {
                q.pop_back();
            }

            if (q.empty()) {
                dp2[i] = (1LL * strength[i - 1] * i) % MOD;
                dp1[i] = (dp1[i] + strength[i - 1] * sum1[i] % MOD * i % MOD) % MOD;
                dp1[i] = (dp1[i] - strength[i - 1] * sum2[i - 1] % MOD) % MOD;
            } else {
                int k = q.back() + 1;
                dp2[i] = (dp2[k] + 1LL * strength[i - 1] * (i - k)) % MOD;
                dp1[i] = (dp1[k] + (sum1[i] - sum1[k]) % MOD * dp2[k] % MOD) % MOD;

                dp1[i] = (dp1[i] + strength[i - 1] * sum1[i] % MOD * (i - k) % MOD) % MOD;
                dp1[i] = (dp1[i] - strength[i - 1] * (sum2[i - 1] - sum2[k - 1]) % MOD) % MOD;
            }

            dp1[i] = (dp1[i] + MOD) % MOD;
            q.push_back(i - 1);
            ans = (ans + dp1[i]) % MOD;
        }
        return ans;
    }
};
```
